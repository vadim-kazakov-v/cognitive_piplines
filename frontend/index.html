<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Cognitive Pipelines UI</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <link rel="stylesheet" href="lib/litegraph.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
    <style>
    html, body {
      height: 100%;
      margin: 0;
      color: #ddd;
      background: #222;
    }
    body {
      display: flex;
      overflow: hidden;
      font-family: sans-serif;
    }
    .glass {
      background: #2b2b2b;
      border-radius: 0;
      border: 1px solid #444;
      box-shadow: none;
    }
    #sidebar {
      width: 220px;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      border-right: 1px solid #444;
      overflow-y: auto;
    }
    #sidebar button,
    #sidebar input,
    #layout-mode {
      background: #444;
      border: 1px solid #666;
      border-radius: 0;
      color: #fff;
      padding: 6px 8px;
    }
    #sidebar button {
      cursor: pointer;
      text-align: left;
    }
    #node-list button {
      width: 100%;
      box-sizing: border-box;
    }
    #sidebar button:hover {
      background: #555;
    }
    #sidebar h3 {
      margin: 8px 0 4px;
      font-size: 14px;
    }
    #main {
      flex: 1;
      display: flex;
    }
    #graph {
      flex: 1;
      width: 100%;
      height: 100%;
      background: #1e1e1e;
    }
  </style>
</head>
<body>
  <div id="sidebar" class="glass">
    <button id="run-btn">Run</button>
    <button id="step-btn">Step</button>
    <button id="stop-btn">Stop</button>
    <button id="save-flow">Save Flow</button>
    <button id="load-flow">Load Flow</button>
    <select id="layout-mode">
      <option value="horizontal">Horizontal</option>
      <option value="vertical">Vertical</option>
    </select>
    <button id="layout-btn">Auto Layout</button>
    <h3>Presets</h3>
    <div id="preset-list"></div>
    <input id="file-input" type="file" accept="application/json" style="display:none" />
    <input id="node-search" placeholder="Search nodes (e.g., HyperDR)" />
    <div id="node-list"></div>
  </div>
  <div id="main" class="glass">
    <canvas id="graph"></canvas>
  </div>
  <script src="lib/litegraph.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/highlight.min.js"></script>
  <script>
    // Highlight.js may fail to load (e.g. offline) which would previously
    // cause a ReferenceError and stop the rest of the script from running.
    // Guard the call so the UI continues to work even without syntax
    // highlighting.
    if (window.hljs) {
      hljs.highlightAll();
    }
    // Adjust zoom sensitivity so scroll (mouse wheel) on the graph canvas
    // feels smoother.
    LGraphCanvas.prototype.processMouseWheel = function(e) {
      if (this.graph && this.allow_dragcanvas) {
        const delta = e.wheelDeltaY !== undefined ? e.wheelDeltaY : -60 * e.detail;
        this.adjustMouseEvent(e);
        const x = e.clientX;
        const y = e.clientY;
        if (!this.viewport || (x >= this.viewport[0] && x < this.viewport[0] + this.viewport[2] &&
                               y >= this.viewport[1] && y < this.viewport[1] + this.viewport[3])) {
          let scale = this.ds.scale;
          if (delta > 0) {
            scale *= 1.05; // smaller step for smoother zoom
          } else if (delta < 0) {
            scale *= 1 / 1.05;
          }
          this.ds.changeScale(scale, [e.clientX, e.clientY]);
          this.graph.change();
          e.preventDefault();
          return false;
        }
      }
    };
    const graph = new LGraph();
    const canvas = new LGraphCanvas("#graph", graph);
    canvas.render_shadows = false;
    canvas.round_radius = 12;
    LiteGraph.NODE_DEFAULT_SHAPE = LiteGraph.ROUND_SHAPE;
    LiteGraph.NODE_DEFAULT_BGCOLOR = "rgba(255,255,255,0)";
    LiteGraph.NODE_DEFAULT_COLOR = "rgba(255,255,255,0)";
    LiteGraph.NODE_DEFAULT_BOXCOLOR = "rgba(255,255,255,0)";
    LiteGraph.NODE_TITLE_COLOR = "#000";
    canvas.allow_interaction = canvas.allow_dragcanvas = canvas.allow_dragnodes = true;
    canvas.allow_searchbox = false;
    // single click selects one node; hold Shift/Ctrl for multi-select
    canvas.multi_select = false;
    document.getElementById('main').addEventListener('dblclick', e => {
      e.preventDefault();
      e.stopPropagation();
    }, true);

    function resizeCanvas() {
      const rect = document.getElementById('main').getBoundingClientRect();
      canvas.resize(rect.width, rect.height);
      canvas.setZoom(1, [rect.width / 2, rect.height / 2]);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const groups = {};
    function registerNode(path, nodeClass) {
      LiteGraph.registerNodeType(path, nodeClass);
      const [group, name] = path.split('/');
      let container = groups[group];
      if (!container) {
        container = document.createElement('div');
        const header = document.createElement('h3');
        header.textContent = group;
        const list = document.createElement('div');
        container.appendChild(header);
        container.appendChild(list);
        document.getElementById('node-list').appendChild(container);
        container.list = list;
        groups[group] = container;
      }
      const btn = document.createElement('button');
      btn.dataset.node = path;
      btn.textContent = `${nodeClass.icon || ''} ${nodeClass.title || name}`;
      btn.draggable = true;
      btn.addEventListener('dragstart', e => {
        e.dataTransfer.setData('node', path);
      });
      container.list.appendChild(btn);
    }

    let lastNode = null;
    document.getElementById('node-list').addEventListener('click', e => {
      if (!e.target.dataset.node) return;
      const node = LiteGraph.createNode(e.target.dataset.node);
      node.pos = [Math.random() * 400 + 100, Math.random() * 200 + 100];
      graph.add(node);
      if (lastNode && lastNode.outputs?.length && node.inputs?.length) {
        lastNode.connect(0, node, 0);
      }
      lastNode = node;
    });

    canvas.canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.canvas.addEventListener('drop', e => {
      e.preventDefault();
      const type = e.dataTransfer.getData('node');
      if (!type) return;
      canvas.adjustMouseEvent(e);
      const node = LiteGraph.createNode(type);
      if (!node) return;
      node.pos = [e.canvasX, e.canvasY];
      graph.add(node);
      if (lastNode && lastNode.outputs?.length && node.inputs?.length) {
        lastNode.connect(0, node, 0);
      }
      lastNode = node;
    });

    document.getElementById('run-btn').addEventListener('click', () => {
      graph.start();
    });
    document.getElementById('step-btn').addEventListener('click', async () => {
      graph.runStep(1);
      let safety = 0;
      while (graph._nodes.some(n => n._pending) && safety++ < 50) {
        await new Promise(resolve => requestAnimationFrame(resolve));
        graph.runStep(1);
      }
    });
    document.getElementById('stop-btn').addEventListener('click', () => {
      graph.stop();
    });
    function autoLayout() {
      const mode = document.getElementById('layout-mode').value;
      graph.arrange(100, mode === 'vertical' ? LiteGraph.VERTICAL_LAYOUT : undefined);
    }
    document.getElementById('layout-btn').addEventListener('click', autoLayout);
    document.getElementById('save-flow').addEventListener('click', () => {
      const data = JSON.stringify(graph.serialize(), null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'flow.json';
      a.click();
    });
    document.getElementById('load-flow').addEventListener('click', () => {
      document.getElementById('file-input').click();
    });
    document.getElementById('file-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      file.text().then(txt => {
        const data = JSON.parse(txt);
        graph.clear();
        graph.configure(data);
      });
    });

    const search = document.getElementById('node-search');
    search.addEventListener('input', () => {
      const term = search.value.toLowerCase();
      document.querySelectorAll('#node-list button').forEach(btn => {
        btn.style.display = btn.textContent.toLowerCase().includes(term) ? '' : 'none';
      });
    });

    function groupSelectedNodes() {
      const selected = Object.values(canvas.selected_nodes || {});
      if (selected.length < 2) return;
      const bounds = selected.reduce((acc, n) => {
        acc.left = Math.min(acc.left, n.pos[0]);
        acc.top = Math.min(acc.top, n.pos[1]);
        acc.right = Math.max(acc.right, n.pos[0] + n.size[0]);
        acc.bottom = Math.max(acc.bottom, n.pos[1] + n.size[1]);
        return acc;
      }, {left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity});
      const group = new LGraphGroup("Group");
      group.pos = [bounds.left - 40, bounds.top - 40];
      group.size = [bounds.right - bounds.left + 80, bounds.bottom - bounds.top + 80];
      graph.add(group);
      selected.forEach(n => group.add(n));
      canvas.setDirty(true, true);
    }

    canvas.canvas.addEventListener('click', e => {
      if (Object.keys(canvas.selected_nodes).length > 1 && !e.shiftKey && !e.ctrlKey) {
        canvas.adjustMouseEvent(e);
        if (!graph.getNodeOnPos(e.canvasX, e.canvasY)) {
          groupSelectedNodes();
        }
      }
    });

    graph.onNodeAdded = node => {
      console.log(`${node.title || node.type} movable:`, canvas.allow_dragnodes && !(node.flags && node.flags.not_movable));
      node.color = "rgba(255,255,255,0)";
      node.bgcolor = "rgba(255,255,255,0)";
      node.boxcolor = "rgba(255,255,255,0)";
      const origBg = node.onDrawBackground;
      node.onDrawBackground = function(ctx) {
        if (this.flags && this.flags.collapsed) return;
        const w = this.size[0];
        const h = this.size[1];
        const r = 12;
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(0,0,w,h,r);
        else {
          ctx.moveTo(r,0);
          ctx.lineTo(w - r,0);
          ctx.quadraticCurveTo(w,0,w,r);
          ctx.lineTo(w,h - r);
          ctx.quadraticCurveTo(w,h,w - r,h);
          ctx.lineTo(r,h);
          ctx.quadraticCurveTo(0,h,0,h - r);
          ctx.lineTo(0,r);
          ctx.quadraticCurveTo(0,0,r,0);
        }
        ctx.fillStyle = "#333";
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 1;
        ctx.fill();
        ctx.stroke();
        ctx.restore();
        if (origBg) origBg.call(this, ctx);
      };

      const origExec = node.onExecute;
      if (origExec) {
        node.onExecute = async function(...args) {
          const prev = this.color;
          this.color = '#888';
          this.setDirtyCanvas(true, true);
          try {
            return await origExec.apply(this, args);
          } finally {
            this.color = prev;
            this.setDirtyCanvas(true, true);
          }
        };
      }
      if (node.properties) {
        const origDraw = node.onDrawForeground;
        node.onDrawForeground = function(ctx) {
          if (origDraw) origDraw.call(this, ctx);
          if (!this.selected) return;
          let y = 20;
          ctx.fillStyle = '#000';
          ctx.font = '12px sans-serif';
          for (const key in this.properties) {
            const val = this.properties[key];
            ctx.fillText(`${key}: ${Math.round(val * 1000) / 1000}`, 4, y);
            y += 14;
          }
        };
      }
    };

    function presetSimpleUMAP() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const umap = LiteGraph.createNode('ml/umap');
      umap.pos = [250, 150];
      const scatter = LiteGraph.createNode('viz/scatter2d');
      scatter.pos = [450, 150];
      graph.add(titanic);
      graph.add(umap);
      graph.add(scatter);
      titanic.connect(0, umap, 0);
      umap.connect(0, scatter, 0);
    }

    function presetUmapDbscanPlot() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      const umap = LiteGraph.createNode('ml/umap');
      umap.pos = [450, 150];
      const scatter = LiteGraph.createNode('viz/scatter2d');
      scatter.pos = [650, 150];
      const dbscan = LiteGraph.createNode('ml/dbscan');
      dbscan.pos = [450, 350];
      const log = LiteGraph.createNode('util/log');
      log.pos = [650, 350];
      graph.add(titanic);
      graph.add(select);
      graph.add(umap);
      graph.add(scatter);
      graph.add(dbscan);
      graph.add(log);
      titanic.connect(0, select, 0);
      select.connect(1, umap, 0);
      umap.connect(0, scatter, 0);
      umap.connect(0, dbscan, 0);
      dbscan.connect(0, log, 0);
    }

    function presetHistogram() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.fields = ['Fare'];
      const bar = LiteGraph.createNode('viz/bar');
      bar.pos = [450, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(bar);
      titanic.connect(0, select, 0);
      select.connect(1, bar, 0);
    }

    function presetPython() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.field = 'Fare';
      const py = LiteGraph.createNode('util/python');
      py.pos = [450, 150];
      py.properties.code = "[{'double': v*2} for v in data]";
      const table = LiteGraph.createNode('viz/table');
      table.pos = [650, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(py);
      graph.add(table);
      titanic.connect(0, select, 0);
      select.connect(0, py, 0);
      py.connect(0, table, 0);
    }

    function presetTsne() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.fields = ['Fare', 'Age'];
      const tsne = LiteGraph.createNode('ml/tsne');
      tsne.pos = [450, 150];
      const scatter = LiteGraph.createNode('viz/scatter2d');
      scatter.pos = [650, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(tsne);
      graph.add(scatter);
      titanic.connect(0, select, 0);
      select.connect(1, tsne, 0);
      tsne.connect(0, scatter, 0);
    }

    function presetUmap3D() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.fields = ['Fare', 'Age', 'Pclass'];
      const umap = LiteGraph.createNode('ml/umap');
      umap.pos = [450, 150];
      umap.properties.n_components = 3;
      const scatter = LiteGraph.createNode('viz/scatter3d');
      scatter.pos = [650, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(umap);
      graph.add(scatter);
      titanic.connect(0, select, 0);
      select.connect(1, umap, 0);
      umap.connect(0, scatter, 0);
    }

    function presetViolin() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.field = 'Age';
      const violin = LiteGraph.createNode('viz/violin');
      violin.pos = [450, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(violin);
      titanic.connect(0, select, 0);
      select.connect(0, violin, 0);
    }

    function presetPieChart() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.field = 'Pclass';
      const py = LiteGraph.createNode('util/python');
      py.pos = [450, 150];
      py.properties.code = `from collections import Counter
result = Counter(data)`;
      const pie = LiteGraph.createNode('viz/pie');
      pie.pos = [650, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(py);
      graph.add(pie);
      titanic.connect(0, select, 0);
      select.connect(0, py, 0);
      py.connect(0, pie, 0);
    }

    function presetSankey() {
      const titanic = LiteGraph.createNode('data/titanic');
      titanic.pos = [50, 150];
      const select = LiteGraph.createNode('transform/select');
      select.pos = [250, 150];
      select.properties.fields = ['Pclass', 'Survived'];
      const py = LiteGraph.createNode('util/python');
      py.pos = [450, 150];
      py.properties.code = `from collections import defaultdict

nodes = []
index = {}

def get_index(name):
    if name not in index:
        index[name] = len(nodes)
        nodes.append({'name': name})
    return index[name]

links = defaultdict(int)
for row in data:
    s = get_index(f"Pclass {row['Pclass']}")
    t = get_index(f"Survived {row['Survived']}")
    links[(s, t)] += 1

result = {
    'nodes': nodes,
    'links': [{'source': s, 'target': t, 'value': v} for (s, t), v in links.items()]
}`;
      const sankey = LiteGraph.createNode('viz/sankey');
      sankey.pos = [650, 150];
      graph.add(titanic);
      graph.add(select);
      graph.add(py);
      graph.add(sankey);
      titanic.connect(0, select, 0);
      select.connect(1, py, 0);
      py.connect(0, sankey, 0);
    }

    function presetRandomGraph() {
      const gen = LiteGraph.createNode('data/random_graph');
      gen.pos = [50, 150];
      const viz = LiteGraph.createNode('viz/graph');
      viz.pos = [250, 150];
      graph.add(gen);
      graph.add(viz);
      gen.connect(0, viz, 0);
    }

    function presetGlyphs() {
      const rand = LiteGraph.createNode('data/random');
      rand.pos = [50, 150];
      rand.properties.columns = 4;
      rand.properties.count = 9;
      const glyphs = LiteGraph.createNode('viz/glyphs');
      glyphs.pos = [250, 150];
      graph.add(rand);
      graph.add(glyphs);
      rand.connect(0, glyphs, 0);
    }

    function presetRandomScatter() {
      const rand = LiteGraph.createNode('data/random');
      rand.pos = [50, 150];
      rand.properties.columns = 2;
      rand.properties.count = 50;
      const toPts = LiteGraph.createNode('util/python');
      toPts.pos = [250, 150];
      toPts.properties.code = `[ [r['col1'], r['col2']] for r in data ]`;
      const labels = LiteGraph.createNode('data/random_labels');
      labels.pos = [250, 300];
      const scatter = LiteGraph.createNode('viz/scatter2d');
      scatter.pos = [450, 150];
      graph.add(rand);
      graph.add(toPts);
      graph.add(labels);
      graph.add(scatter);
      rand.connect(0, toPts, 0);
      rand.connect(0, labels, 0);
      toPts.connect(0, scatter, 0);
      labels.connect(0, scatter, 1);
    }

    function presetContrastFocus() {
      const py = LiteGraph.createNode('util/python');
      py.pos = [50, 150];
      py.properties.code = "import numpy as np\nresult = np.random.rand(100,100).tolist()";
      const im = LiteGraph.createNode('viz/imshow');
      im.pos = [250, 150];
      const mask = LiteGraph.createNode('util/python');
      mask.pos = [250, 300];
      mask.properties.code = "[30, 30, 40, 40]";
      const focus = LiteGraph.createNode('viz/contrast_focus');
      focus.pos = [450, 150];
      const view = LiteGraph.createNode('viz/view');
      view.pos = [650, 150];
      graph.add(py);
      graph.add(im);
      graph.add(mask);
      graph.add(focus);
      graph.add(view);
      py.connect(0, im, 0);
      im.connect(0, focus, 0);
      mask.connect(0, focus, 1);
      focus.connect(0, view, 0);
    }

    function presetImShow() {
      const py = LiteGraph.createNode('util/python');
      py.pos = [50, 150];
      py.properties.code = "import numpy as np\nresult = np.random.rand(20,20).tolist()";
      const im = LiteGraph.createNode('viz/imshow');
      im.pos = [250, 150];
      im.properties.cmap = 'viridis';
      im.properties.interpolation = 'bilinear';
      const view = LiteGraph.createNode('viz/view');
      view.pos = [450, 150];
      graph.add(py);
      graph.add(im);
      py.connect(0, im, 0);
    }

    function presetVoronoi() {
      const rand = LiteGraph.createNode('data/random');
      rand.pos = [50, 150];
      rand.properties.columns = 2;
      rand.properties.count = 30;
      const labels = LiteGraph.createNode('data/random_labels');
      labels.pos = [250, 300];
      const vor = LiteGraph.createNode('viz/voronoi');
      vor.pos = [250, 150];
      graph.add(rand);
      graph.add(labels);
      graph.add(vor);
      rand.connect(0, vor, 0);
      rand.connect(0, labels, 0);
      labels.connect(0, vor, 1);
    }

    function presetTDA() {
      graph.configure(JSON.parse(JSON.stringify(TDA_FLOW)));
    }

    function presetBiasReport() {
      graph.configure(JSON.parse(JSON.stringify(BIAS_REPORT_FLOW)));
    }

    function presetRandomForest() {
      graph.configure(JSON.parse(JSON.stringify(RANDOM_FOREST_FLOW)));
    }

    function presetPaletteDemo() {
      const palette = LiteGraph.createNode('perceptual/palette');
      palette.pos = [50, 150];
      const orig = LiteGraph.createNode('util/log');
      orig.pos = [250, 100];
      const sim = LiteGraph.createNode('util/log');
      sim.pos = [250, 200];
      graph.add(palette);
      graph.add(orig);
      graph.add(sim);
      palette.connect(0, orig, 0);
      palette.connect(1, sim, 0);
    }

    function presetUncertainty() {
      graph.configure(JSON.parse(JSON.stringify(UNCERTAINTY_FLOW)));
    }

    const presets = [
      { name: 'Simple UMAP', fn: presetSimpleUMAP },
      { name: 'UMAP + DBSCAN', fn: presetUmapDbscanPlot },
      { name: 'Histogram', fn: presetHistogram },
      { name: 'Python', fn: presetPython },
      { name: 't-SNE', fn: presetTsne },
      { name: 'UMAP 3D', fn: presetUmap3D },
      { name: 'Violin', fn: presetViolin },
      { name: 'Pie Chart', fn: presetPieChart },
      { name: 'Sankey', fn: presetSankey },
      { name: 'Random Graph', fn: presetRandomGraph },
      { name: 'Glyphs', fn: presetGlyphs },
      { name: 'Random Scatter', fn: presetRandomScatter },
      { name: 'Contrast Focus', fn: presetContrastFocus },
      { name: 'ImShow Demo', fn: presetImShow },
      { name: 'Voronoi', fn: presetVoronoi },
      { name: 'Bias Report', fn: presetBiasReport },
      { name: 'TDA Demo', fn: presetTDA },
      { name: 'Random Forest Demo', fn: presetRandomForest },
      { name: 'Uncertainty Demo', fn: presetUncertainty },
      { name: 'Palette Demo', fn: presetPaletteDemo }
    ];

    const presetList = document.getElementById('preset-list');
    presets.forEach(p => {
      const btn = document.createElement('button');
      btn.textContent = p.name;
      btn.addEventListener('click', () => {
        graph.clear();
        const maybePromise = p.fn();
        if (maybePromise && typeof maybePromise.then === 'function') {
          maybePromise.then(() => autoLayout());
        } else {
          autoLayout();
        }
      });
      presetList.appendChild(btn);
    });
  </script>
  <script src="examples/flows.js"></script>
  <script src="nodes/data.js"></script>
  <script src="nodes/transform.js"></script>
  <script src="nodes/visualize.js"></script>
  <script src="nodes/visualizer.js"></script>
  <script src="nodes/perceptual.js"></script>
  <script src="nodes/util.js"></script>
  <script src="nodes/bias.js"></script>
  <script src="nodes/ml.js"></script>
  <script src="nodes/python.js"></script>
  <script>presetSimpleUMAP(); autoLayout(); graph.start();</script>
</body>
</html>
